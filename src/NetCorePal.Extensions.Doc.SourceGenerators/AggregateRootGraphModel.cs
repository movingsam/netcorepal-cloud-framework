using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NetCorePal.Extensions.Doc.SourceGenerators;

public class AggregateRootGraphModel(
    string name,
    string nameSpace,
    AggregateRootPropGraphModel[] properties,
    AggregateRootMethodGraphModel[] methods)
{
    public string Name { get; } = name;
    public string NameSpace { get; } = nameSpace;
    public AggregateRootPropGraphModel[] Properties { get; } = properties;
    public AggregateRootMethodGraphModel[] Methods { get; } = methods;

    public Dictionary<string, AggregateRootMethodGraphModel> DomainEventMethodsDictionary =>
        Methods.Where(x => !string.IsNullOrWhiteSpace(x.DomainEvent))
            .ToDictionary(x => x.DomainEvent!,
                x => x);
    public string FullName => $"{NameSpace}.{Name}";

    private string GetMarkdown()
    {
        return $$"""

                 class {{Name}} {
                     <<AggregateRoot>>
                     {{string.Join("\n\t",
                        Properties.Select(p => $"+ {p.Type} {p.Name}"))}}
                     {{string.Join("\n\t",
                        Methods.Select(m => $"+ {m.Name}({string.Join(", ", m.Parameters.Select(p => $"{p.ClrType} {p.Name}"))}) {m.ReturnType} {m.IsTriggerMethodString} "))}}
                 }
                                 
                 """;
    }

    public override string ToString()
    {
        var markdown = GetMarkdown();
        var className = Name + "MDOutput";
        return $$"""
                 // <auto-generated/>
                 using System;
                 using System.Collections.Generic;
                 using NetCorePal.Extensions.Doc.Abstractions;
                 public class {{className}} : global::NetCorePal.Extensions.Doc.Abstractions.IMarkdownGraphRender
                 {
                     public {{className}}()
                     {
                     }
                 
                     public string MarkdownRender()
                     {
                          return @"{{markdown}}";
                     }
                 }
                                        
                 """;
    }

    public void AddDomainEventHandler(string domainEventType)
    {
        DomainEventMethodsDictionary.TryGetValue(domainEventType,out var domainEventMethod);
        if (domainEventMethod != null)
        {
            
        }
    }
}

public class AggregateRootPropGraphModel(string name, string type)
{
    public string Name { get; } = name;
    public string Type { get; } = type;
}

public class AggregateRootMethodGraphModel
{
    public AggregateRootMethodGraphModel(IMethodSymbol methodSymbol)
    {
        MethodSymbol = methodSymbol ?? throw new ArgumentNullException(nameof(methodSymbol));
        Name = methodSymbol.Name;
        ReturnType = methodSymbol.ReturnType.ToDisplayString();
        Parameters = methodSymbol.Parameters.Select(x => new ClrTypeAndName(x.Type.ToString(), x.Name))
            .ToArray();
    }

    private IMethodSymbol MethodSymbol { get; set; }

    public string Name { get; }
    public string ReturnType { get; }
    public ClrTypeAndName[] Parameters { get; }
    private bool IsTrigger => IsTriggerMethod();
    

    public string IsTriggerMethodString => IsTrigger ? "trigger "+ DomainEvent : string.Empty;
    public string? DomainEvent { get; private set; }

    private SemanticModel GetSemanticModel(SyntaxTree syntaxTree)
    {
        var compilation = CSharpCompilation.Create("TempAssembly")
            .AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location))
            .AddSyntaxTrees(syntaxTree);
        return compilation.GetSemanticModel(syntaxTree);
    }
    private bool IsTriggerMethod()
    {
        if (MethodSymbol.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax()
            is not MethodDeclarationSyntax methodSyntax) return false;
        // 遍历方法体内的调用表达式
        var invocations = methodSyntax.DescendantNodes()
            .OfType<InvocationExpressionSyntax>();
        
        var semanticModel = GetSemanticModel(methodSyntax.SyntaxTree);
        foreach (var invocation in invocations)
        {
            // 获取调用的方法名
            var methodName = invocation.Expression.ToString();
            // 判断是否是触发器方法
            if (methodName.Contains("AddDomainEvent"))
            {
                var domainEvent = semanticModel
                    .GetTypeInfo(invocation.ArgumentList.Arguments[0].Expression)
                    .Type?.Name ?? string.Empty;
                SetDomainEvent(domainEvent);
                return true;
            }
        }

        return false;
    }
    
    private void SetDomainEvent(string domainEvent)
    {
        DomainEvent = domainEvent;
    }

    public class ClrTypeAndName(string clrType, string name)
    {
        public string ClrType { get; } = clrType;
        public string Name { get; } = name;
    }
}